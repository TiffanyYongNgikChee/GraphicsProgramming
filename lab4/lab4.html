<!DOCTYPE html>

<html>
  <script src="https://code.jquery.com/jquery-3.1.0.min.js"></script>
  <head>
    <meta charset="UTF-8">
    <title>Canvas</title>

    <style type="text/css">
      body {
          background-color: white;
      }
      canvas{
            border: 10px solid black; /*Draw a black border around the canvas*/
            pointer-events: none; /* This allows mouse events to pass through to the main canvas */
        }
    </style>

  </head>

  <body>
    <h1>Tiffany Yong</h1>
    
    <canvas id="canvas-for-ball"width="500" height="500"></canvas>
    <script type="text/javascript">

      const canvas = document.getElementById("canvas-for-ball");
      const ctx = canvas.getContext("2d");
      ctx.fillStyle = "rgb(255, 0, 0)";

      // Initialize scores for each paddle
      let scorePaddleOne = 0;
      let scorePaddleTwo = 0;
      
      class Ball{
        constructor(xPosition,yPosition,xVelocity,yVelocity,radius){
            this.xPosition=xPosition;// The horizontal location of the ball.
            this.yPosition=yPosition;// The vertical location of the ball.
            this.xVelocity=xVelocity;
            this.yVelocity=yVelocity;
            this.radius=radius;
            this.rotation=0;
            this.rotationSpeed = 0.1;  // Initial speed of rotation
            this.color = '#7FC8FF'; // New color property with a default value of "blue"
        }

        draw(){
            // Set the stroke color for visibility (black for both the circle and lines).
            ctx.fillStyle = this.color;
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2; // Optional: Make the line thicker for visibility

            // Draw the horizontal ball (stroked, not filled).
            ctx.beginPath();
            ctx.arc(this.xPosition, this.yPosition, this.radius, 0, 2 * Math.PI);
            ctx.fill();  // Fill the ball with color
            ctx.stroke();

            // Increment the rotation angle by 0.1 radians for continuous rotation.
            this.rotation=this.rotation+0.1;

            // Function to convert polar to cartesian coordinates.
            const polarToCartesian = (radius, angle, centerX, centerY) => {
                return {
                    x: centerX + radius * Math.cos(angle),
                    y: centerY + radius * Math.sin(angle)
                };
            };

            // Calculate and draw lines to multiple points on the ball.
            // 45 degrees (π/4) offset from the current rotation
            let point1 = polarToCartesian(this.radius, Math.PI / 4 + this.rotation, this.xPosition, this.yPosition);
            ctx.moveTo(this.xPosition, this.yPosition);
            ctx.lineTo(point1.x, point1.y);
            ctx.stroke();

            // 135 degrees (3π/4) offset from the current rotation
            let point2 = polarToCartesian(this.radius, 3 * Math.PI / 4 + this.rotation, this.xPosition, this.yPosition);
            ctx.moveTo(this.xPosition, this.yPosition);
            ctx.lineTo(point2.x, point2.y);
            ctx.stroke();

            // 90 degrees (π/2) top of the circle
            let point3 = polarToCartesian(this.radius, Math.PI / 2 + this.rotation, this.xPosition, this.yPosition);
            ctx.moveTo(this.xPosition, this.yPosition);
            ctx.lineTo(point3.x, point3.y);
            ctx.stroke();

            // 270 degrees (3π/2) bottom of the circle
            let point4 = polarToCartesian(this.radius, 3 * Math.PI / 2 + this.rotation, this.xPosition, this.yPosition);
            ctx.moveTo(this.xPosition, this.yPosition);
            ctx.lineTo(point4.x, point4.y);
            ctx.stroke();
        }
        move(){
            // Update the y location.
            this.yPosition += this.yVelocity;
            this.xPosition += this.xVelocity;
            const stoppingPoint=500-this.radius;

             //If the ball hits the bottom of the canvas
            if(this.yPosition >= stoppingPoint){
                //Change ball's direction.(reverse the speed)
                console.log("hit bottom of screen");
                this.yVelocity=this.yVelocity*-1;
                this.rotationSpeed *= -1;  // Reverse rotation direction
            }
            //Otherwise, if the ball hit the top
            else if(this.yPosition <= this.radius){
                this.yVelocity=this.yVelocity*-1;
            }

            if(this.xPosition >= stoppingPoint)
            {
                console.log("hit top of screen");
                this.xVelocity=this.xVelocity*-1;
                this.rotationSpeed *= -1;  // Reverse rotation direction
                scorePaddleTwo--;  // Decrease score for PaddleTwo when it hits the right wall
            }
            else if(this.xPosition <= this.radius)
            {
                this.xVelocity=this.xVelocity*-1;
                scorePaddleOne--;  // Decrease score for PaddleOne when it hits the left wall
            }
            
      
        }
        // Method to reverse direction (velocity) upon collision
        reverseDirection() {
            this.xVelocity *= -1;
            this.yVelocity *= -1;
        }

        // Method to increase ball speed
        increaseSpeed() {
            this.xVelocity *= 1.2;  // Increase velocity by 20%
            this.yVelocity *= 1.2;
        }

        // Method to decrease ball speed
        decreaseSpeed() {
            this.xVelocity *= 0.8;  // Decrease velocity by 20%
            this.yVelocity *= 0.8;
        }

        rotate(){
            // Increment the rotation by the rotationSpeed.
            this.rotation += this.rotationSpeed;
        }
    }
      class Paddle{
        constructor(xPosition,yPosition,xVelocity,yVelocity,radius){
            this.xPosition=xPosition;// The horizontal location of the ball.
            this.yPosition=yPosition;// The vertical location of the ball.
            this.xVelocity=xVelocity;
            this.yVelocity=yVelocity;
            this.radius=radius;
            this.speed = 10;            // Speed for moving the paddle
        }

        // Method to draw the paddle on the canvas with some advanced symbol as the Ball Class
        draw(){
            // Set the stroke color for visibility (black for both the circle and lines).
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2; // Optional: Make the line thicker for visibility

            // Draw the "match ball" symbol within the paddle
            ctx.fillStyle = "yellow"; // Make the symbol a different color
            ctx.beginPath();
            ctx.arc(this.xPosition, this.yPosition, this.radius, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();


            const polarToCartesian = (radius, angle, centerX, centerY) => {
                return {
                    x: centerX + radius * Math.cos(angle),
                    y: centerY + radius * Math.sin(angle)
                };
            };

            let point1 = polarToCartesian(this.radius, Math.PI / 4, this.xPosition, this.yPosition);
            ctx.moveTo(this.xPosition, this.yPosition);
            ctx.lineTo(point1.x, point1.y);
            ctx.stroke();

            let point2 = polarToCartesian(this.radius, 3 * Math.PI / 4 , this.xPosition, this.yPosition);
            ctx.moveTo(this.xPosition, this.yPosition);
            ctx.lineTo(point2.x, point2.y);
            ctx.stroke();

            let point3 = polarToCartesian(this.radius, Math.PI / 2 , this.xPosition, this.yPosition);
            ctx.moveTo(this.xPosition, this.yPosition);
            ctx.lineTo(point3.x, point3.y);
            ctx.stroke();

            let point4 = polarToCartesian(this.radius, 3 * Math.PI / 2 , this.xPosition, this.yPosition);
            ctx.moveTo(this.xPosition, this.yPosition);
            ctx.lineTo(point4.x, point4.y);
            ctx.stroke();
        }

        move(){
            
        }
        move_keyboard(direction){
            switch(direction){
            case 83: // 'S' key
            case 40: // Down arrow
                if(this.yPosition - this.speed <= this.radius) return; // Move up
                this.yPosition -= this.speed;
                break;
            case 87: // 'W' key
            case 38: // Up arrow
            
                if(this.yPosition + this.speed >= canvas.height - this.radius) return; // Move down
                this.yPosition += this.speed;
                break;
            }
        }
        
      }
      myBall = new Ball(20,20,5,2,20);
      var paddleOne = new Paddle(20, 250, 5, 2, 20);
      var paddleTwo = new Paddle(480, 250, 5, 2, 20);

      let collisionMessage = '';
      let collisionMessageTimeout = null;

      // A function to detect collisions between the Paddle ball and the “match ball”
      function checkCollisions(){
        var dist_1= Math.sqrt(Math.pow(paddleOne.xPosition-myBall.xPosition,2)+Math.pow(paddleOne.yPosition-myBall.yPosition,2));
        var dist_2= Math.sqrt(Math.pow(paddleTwo.xPosition-myBall.xPosition,2)+Math.pow(paddleTwo.yPosition-myBall.yPosition,2));
        //console.log(dist);

        if (dist_1 < paddleOne.radius + myBall.radius) {
          collisionMessage = "Collision Detected!";
          myBall.reverseDirection();
          scorePaddleOne++;  // Increment score for PaddleOne on collision

          if (collisionMessageTimeout) {
            clearTimeout(collisionMessageTimeout);
          }

          collisionMessageTimeout = setTimeout(() => {
            collisionMessage = '';
          }, 750);
          
        } else if (dist_2 < paddleTwo.radius + myBall.radius) {
          collisionMessage = "Collision Detected!";
          myBall.reverseDirection();
          scorePaddleTwo++;  // Increment score for PaddleTwo on collision

          if (collisionMessageTimeout) {
            clearTimeout(collisionMessageTimeout);
          }

          collisionMessageTimeout = setTimeout(() => {
            collisionMessage = '';
          }, 750);
        }

      }

      // Function to display the collision message
      function displayMessage() {
        if (collisionMessage) {
          ctx.font = "20px Arial";
          ctx.fillStyle = "red";
          ctx.fillText(collisionMessage, canvas.width / 2 - 100, canvas.height / 2);
        }
        // Display the scores for both paddles
        ctx.font = "20px Arial";
        ctx.fillStyle = "blue";
        ctx.fillText("Paddle One: " + scorePaddleOne, 20, 30);
        ctx.fillText("Paddle Two: " + scorePaddleTwo, canvas.width - 150, 30);
      }

      // A function to repeat every time the animation loops.
      function repeatme() {

        ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
        myBall.draw();
        paddleOne.draw();
        paddleTwo.draw();
        myBall.move();
        myBall.rotate();
        checkCollisions();
        displayMessage();
        window.requestAnimationFrame(repeatme);
      }

      // Get the animation going.
      repeatme();

      // stores these coordinates (x and y) in an object named canvasPosition
      var canvasPosition = {
        x: canvas.offsetLeft, // Horizontal offset from the left side
        y: canvas.offsetTop // Vertical offset from the top side
      };
      
      // Add a Javascript event listener to the keypress event.
	  window.addEventListener("keydown", function(event) { 
			// Just log the event to the console.
			console.log(event);
	  });

	  //keypresses with jQuery
	  $(document.body).on('keydown', function(e) {
			console.log(e.which);
			switch (e.which) {
			// key code for left arrow
			case 87:
				console.log('S key pressed!');
        paddleTwo.move_keyboard(83);
				break;
            // key code for up arrow
      case 38:
        upPressed = true;
				console.log('up arrow key pressed!');
        paddleOne.move_keyboard(40);
				break;
			// key code for right arrow
			case 83:
				console.log('W key pressed!');
        paddleTwo.move_keyboard(87);
				break;
			// key code for down arrow
			case 40:
        downPressed = true;
				console.log('down arrow key pressed!');
        paddleOne.move_keyboard(38);
				break;
      // '+' key to increase ball speed (key code for '+' on most keyboards)
      case 187:  
        myBall.increaseSpeed();
        break;
      // '-' key to decrease ball speed (key code for '-' on most keyboards)
      case 189:  
        myBall.decreaseSpeed();
        break;
			}
	  });
      
      
    </script>

  </body>

</html>