<!DOCTYPE html>

<html>

  <head>
    <meta charset="UTF-8">
    <title>Canvas</title>

    <style type="text/css">
      body {
          background-color: white;
      }
      canvas{
            border: 10px solid black; /*Draw a black border around the canvas*/
        }
    </style>

  </head>

  <body>
    <h1>Tiffany Yong</h1>
    <canvas id="canvas-for-ball"width="500" height="500"></canvas>

    <script type="text/javascript">

      // Gets a handle to the element with id canvasOne.
      var canvas = document.getElementById("canvas-for-ball");
      // Get a 2D context for the canvas.
      var ctx = canvas.getContext("2d");

      class Paddle{
        constructor(xPosition,yPosition,xVelocity,yVelocity,radius){
            this.xPosition=xPosition;// The horizontal location of the ball.
            this.yPosition=yPosition;// The vertical location of the ball.
            this.xVelocity=xVelocity;
            this.yVelocity=yVelocity;
            this.radius=radius;
        }

        // Modify the Paddle class so that a circle (rather than a rectangle) is drawn
        draw(){
            // Set the stroke color for visibility (black for both the circle and lines).
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2; // Optional: Make the line thicker for visibility

            // Draw the horizontal ball (stroked, not filled).
            ctx.beginPath();
            ctx.arc(this.xPosition, this.yPosition, this.radius, 0, 2 * Math.PI);
            ctx.stroke();
        }

        move(){
            // Update the y location.
            this.yPosition += this.yVelocity;
            this.xPosition += this.xVelocity;
            const stoppingPoint=500-this.radius;

             //If the ball hits the bottom of the canvas
            if(this.yPosition >= stoppingPoint){
                //Change ball's direction.(reverse the speed)
                console.log("hit bottom of screen");
                this.yVelocity=this.yVelocity*-1;
                this.rotationSpeed *= -1;  // Reverse rotation direction
            }
            //Otherwise, if the ball hit the top
            else if(this.yPosition <= this.radius){
                this.yVelocity=this.yVelocity*-1;
            }

            if(this.xPosition >= stoppingPoint)
            {
                console.log("hit top of screen");
                this.xVelocity=this.xVelocity*-1;
                this.rotationSpeed *= -1;  // Reverse rotation direction
            }
            else if(this.xPosition <= this.radius)
            {
                this.xVelocity=this.xVelocity*-1;
            }
        }

        move_keyboard(direction){
            switch(direction){
            // key code for up arrow
            case 87:
            case 38:
                if(this.yPosition + this.speed >= canvas.height - this.height) return;
                this.yPosition += this.speed;
				break;
            // key code for down arrow
            case 83:
			case 40:
                if(this.yPosition - this.speed <= 0) return;
                this.yPosition -= this.speed;
				break;
            }
        }
      }
    
      PaddleOne = new Paddle(20,20,5,2,20);

      // A function to repeat every time the animation loops.
      function repeatme() {
        //clear the entire canvas
        ctx.clearRect(0,0,500,500);
        PaddleOne.draw();
        PaddleOne.move();
        
        
        window.requestAnimationFrame(repeatme);
      }
      
      // Get the animation going.
      repeatme();
    </script>

  </body>

</html>